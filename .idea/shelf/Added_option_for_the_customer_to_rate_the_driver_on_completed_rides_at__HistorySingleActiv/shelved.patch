Index: app/src/main/java/hema/bakr/uperapp/CustomerMapActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package hema.bakr.uperapp;\r\n\r\nimport android.Manifest;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.location.Location;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\nimport android.os.Looper;\r\nimport android.support.annotation.NonNull;\r\nimport android.support.v4.app.ActivityCompat;\r\nimport android.support.v4.app.FragmentActivity;\r\nimport android.support.v4.content.ContextCompat;\r\nimport android.support.v7.app.AlertDialog;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.ImageView;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.RatingBar;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport com.bumptech.glide.Glide;\r\nimport com.firebase.geofire.GeoFire;\r\nimport com.firebase.geofire.GeoLocation;\r\nimport com.firebase.geofire.GeoQuery;\r\nimport com.firebase.geofire.GeoQueryEventListener;\r\nimport com.google.android.gms.common.api.Status;\r\nimport com.google.android.gms.location.FusedLocationProviderClient;\r\nimport com.google.android.gms.location.LocationCallback;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationResult;\r\nimport com.google.android.gms.location.LocationServices;\r\nimport com.google.android.gms.maps.CameraUpdateFactory;\r\nimport com.google.android.gms.maps.GoogleMap;\r\nimport com.google.android.gms.maps.OnMapReadyCallback;\r\nimport com.google.android.gms.maps.SupportMapFragment;\r\nimport com.google.android.gms.maps.model.BitmapDescriptorFactory;\r\nimport com.google.android.gms.maps.model.LatLng;\r\nimport com.google.android.gms.maps.model.Marker;\r\nimport com.google.android.gms.maps.model.MarkerOptions;\r\nimport com.google.android.libraries.places.api.Places;\r\nimport com.google.android.libraries.places.api.model.Place;\r\nimport com.google.android.libraries.places.widget.AutocompleteSupportFragment;\r\nimport com.google.android.libraries.places.widget.listener.PlaceSelectionListener;\r\nimport com.google.firebase.auth.FirebaseAuth;\r\nimport com.google.firebase.database.DataSnapshot;\r\nimport com.google.firebase.database.DatabaseError;\r\nimport com.google.firebase.database.DatabaseReference;\r\nimport com.google.firebase.database.FirebaseDatabase;\r\nimport com.google.firebase.database.ValueEventListener;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class CustomerMapActivity extends FragmentActivity implements OnMapReadyCallback {\r\n\r\n\r\n    //The class tag is used for Logging the errors\r\n    private static final String TAG = \"MapActivity\";\r\n\r\n    //Checking for canceling the request\r\n    private Boolean mRequestBol = false;\r\n\r\n    //Default zoom for the driver location\r\n    private static final float DEFAULT_ZOOM = 17f;\r\n\r\n    // This variable indicates weather the permissions needed are granted\r\n    private Boolean mLocationPermissionsGranted = false;\r\n\r\n    //This is the  top priority variable that holds the map\r\n    private GoogleMap mMap;\r\n\r\n    //This variable is needed to get the driver location\r\n    private FusedLocationProviderClient mFusedLocationProviderClient;\r\n\r\n    //Marker indicating the driver location\r\n    Marker mCurrLocationMarker;\r\n\r\n    //reference to the pickup request button\r\n    private Button mRequest;\r\n\r\n    //The pickup location\r\n    private LatLng mPickupLocation;\r\n\r\n    //Holds the last valid location for the customer\r\n    Location mLastLocation;\r\n\r\n    //This variable is for making updating the location of the driver by requesting as needed\r\n    LocationRequest mLocationRequest;\r\n\r\n    //The LatLng of the destination location\r\n    private LatLng destinationLatLng;\r\n\r\n    //For Removing marker when cancel the request\r\n    private Marker mPickupMarker;\r\n    // settings button for customer data\r\n    private Button mSettings;\r\n    //reference to the History button\r\n    private Button mHistory;\r\n\r\n    private RatingBar ratingBar;\r\n\r\n    private String mDestination;\r\n\r\n    private LinearLayout mDriverInfo;\r\n    private ImageView mDriverProfileImage;\r\n    private TextView mDriverName, mDriverPhone, mDriverCar;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_customer_map);\r\n\r\n        getLocationPermission();\r\n        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()\r\n                .findFragmentById(R.id.map);\r\n\r\n        mapFragment.getMapAsync(this);\r\n\r\n\r\n        //Setting default value for the destination location if user didn't set it\r\n        destinationLatLng = new LatLng(0.0, 0.0);\r\n\r\n        mDriverInfo = findViewById(R.id.driverInfo);\r\n        mDriverName = findViewById(R.id.driverName);\r\n        mDriverPhone = findViewById(R.id.driverPhone);\r\n        mDriverProfileImage = findViewById(R.id.driverProfileImage);\r\n        mDriverCar = findViewById(R.id.driverCar);\r\n\r\n        ratingBar = findViewById(R.id.ratingBar);\r\n\r\n        // Construct a FusedLocationProviderClient.\r\n        mFusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this);\r\n\r\n        //A reference to the logout button\r\n        Button mLogout = findViewById(R.id.logout);\r\n\r\n        //A reference to the pickup request  button\r\n        mRequest = findViewById(R.id.request);\r\n\r\n        //A reference to the pickup settings  button\r\n        mSettings = findViewById(R.id.settings);\r\n\r\n        //A reference to the pickup History button\r\n        mHistory = findViewById(R.id.history);\r\n\r\n        //Logout function back to MainActivity\r\n        mLogout.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                FirebaseAuth.getInstance().signOut();\r\n                Intent intent = new Intent(CustomerMapActivity.this, MainActivity.class);\r\n                startActivity(intent);\r\n                finish();\r\n            }\r\n        });\r\n\r\n        // Function to make a request, call a driver and Mark my location and save it in Firebase\r\n        mRequest.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //Checking for canceling the request\r\n                if (mRequestBol) {\r\n                    endRide();\r\n                } else {\r\n                    mRequestBol = true;\r\n\r\n                    String userIdd = FirebaseAuth.getInstance().getCurrentUser().getUid();\r\n                    DatabaseReference ref = FirebaseDatabase.getInstance().getReference(\"CustomerRequest\");\r\n                    GeoFire geoFire = new GeoFire(ref);\r\n                    geoFire.setLocation(userIdd, new GeoLocation(mLastLocation.getLatitude(), mLastLocation.getLongitude()), new GeoFire.CompletionListener() {\r\n                        @Override\r\n                        public void onComplete(String key, DatabaseError error) {\r\n                            if (error != null) {\r\n                                Log.e(TAG, \"There was an error saving the location to GeoFire: \" + error);\r\n                            } else {\r\n                                Log.i(TAG, \"Location saved on server successfully!\");\r\n                            }\r\n                        }\r\n                    });\r\n                    mPickupLocation = new LatLng(mLastLocation.getLatitude(), mLastLocation.getLongitude());\r\n                    mPickupMarker = mMap.addMarker(new MarkerOptions().position(mPickupLocation).title(\"Pickup Here\"));\r\n                    mRequest.setText(\"Getting your Drivers...\");\r\n\r\n                    // moSalah >  this functuin determine close driver for your request the implelmetation under\r\n                    getCloserDriver();\r\n                }\r\n            }\r\n        });\r\n\r\n        //setting button\r\n        mSettings.setOnClickListener(new View.OnClickListener() {\r\n\r\n            @Override\r\n            public void onClick(View v) {\r\n\r\n                Intent intent = new Intent(CustomerMapActivity.this, CustomerSettingsActivity.class);\r\n                startActivity(intent);\r\n            }\r\n        });\r\n\r\n        mHistory.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                Intent intent = new Intent(CustomerMapActivity.this, HistoryActivity.class);\r\n                intent.putExtra(\"CustomerOrDriver\", \"Customers\");\r\n                startActivity(intent);\r\n            }\r\n        });\r\n\r\n        Places.initialize(getApplicationContext(), getText(R.string.google_api_key).toString());\r\n        AutocompleteSupportFragment autocompleteFragment = (AutocompleteSupportFragment)\r\n                getSupportFragmentManager().findFragmentById(R.id.autocomplete_fragment);\r\n\r\n        autocompleteFragment.setPlaceFields(Arrays.asList(Place.Field.ID, Place.Field.NAME, Place.Field.LAT_LNG));\r\n\r\n        // Set up a PlaceSelectionListener to handle the response.\r\n        autocompleteFragment.setOnPlaceSelectedListener(new PlaceSelectionListener() {\r\n            @Override\r\n            public void onPlaceSelected(@NonNull Place place) {\r\n                //getting the place name\r\n                mDestination = place.getName();\r\n                //getting the latitude and longitude of the location\r\n                destinationLatLng = place.getLatLng();\r\n            }\r\n\r\n            @Override\r\n            public void onError(@NonNull Status status) {\r\n                Toast.makeText(CustomerMapActivity.this, \"Please check you connection and choose your destination again\", Toast.LENGTH_SHORT).show();\r\n            }\r\n        });\r\n    }\r\n\r\n    // moSalah > video num 9\r\n    private int radius = 1;\r\n    private Boolean driverFound = false;\r\n    private String driverFoundID;\r\n\r\n    //For cancelling listener of getCloserDriver function\r\n    GeoQuery geoQuery;\r\n\r\n    private void getCloserDriver() {\r\n\r\n        DatabaseReference driverLocation = FirebaseDatabase.getInstance().getReference().child(\"DriverAvailable\");\r\n        GeoFire geoFire = new GeoFire(driverLocation);\r\n        geoQuery = geoFire.queryAtLocation(new GeoLocation(mPickupLocation.latitude, mPickupLocation.longitude), radius);\r\n\r\n        geoQuery.removeAllListeners();\r\n\r\n        geoQuery.addGeoQueryEventListener(new GeoQueryEventListener() {\r\n\r\n            @Override\r\n            public void onKeyEntered(String key, GeoLocation location) {\r\n                if (!driverFound && mRequestBol) {\r\n                    driverFound = true;\r\n                    driverFoundID = key;\r\n\r\n                    //Assign the customer ID to the driver that has the pick up request so the driver could know who is he picking\r\n                    DatabaseReference driverRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(driverFoundID).child(\"CustomerRequest\");\r\n                    // Get the current customer ID\r\n                    String customerId = FirebaseAuth.getInstance().getCurrentUser().getUid();\r\n                    HashMap map = new HashMap();\r\n                    map.put(\"CustomerRideId\", customerId);\r\n                    map.put(\"destination\", mDestination);\r\n                    map.put(\"destinationLat\", destinationLatLng.latitude);\r\n                    map.put(\"destinationLng\", destinationLatLng.longitude);\r\n\r\n                    //map.put(customerId, true);\r\n                    driverRef.updateChildren(map);\r\n\r\n                    //A function that gets the driver location .. it is def ined below\r\n                    getDriverLocation();\r\n\r\n                    //A function that gets the driver info\r\n                    getDriverInfo();\r\n\r\n                    //this function keep checking if the request was cancled by the driver and remove it from the database\r\n                    getHasRideEnded();\r\n\r\n                    //Changing the text of the button\r\n                    mRequest.setText(\"Looking for Driver Location ... \");\r\n\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onKeyExited(String key) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onKeyMoved(String key, GeoLocation location) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onGeoQueryReady() {\r\n                if (!driverFound) {\r\n                    // we increse th raduis 1 km to find near driver\r\n                    radius += 50;\r\n                    //call it self\r\n                    getCloserDriver();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onGeoQueryError(DatabaseError error) {\r\n\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    //The driver marker on the map\r\n    private Marker mDriverMarker;\r\n\r\n    //For removing of all Listeners of DatabaseRefrence\r\n    private DatabaseReference mdriverLocationRef;\r\n    private ValueEventListener mdriverLocationRefListener;\r\n\r\n    //This method gets the driver Location and Mark it on the map\r\n    private void getDriverLocation() {\r\n        //L is a list for each driver that has the Latitude and Longitude\r\n        mdriverLocationRef = FirebaseDatabase.getInstance().getReference().child(\"DriverWorking\").child(driverFoundID).child(\"l\");\r\n        // driverLocationRef.setValue(true);\r\n        //final GeoFire geoFireDriver = new GeoFire(driverLocationRef);\r\n        //A listener that keeps tracking the location of the driver\r\n        mdriverLocationRefListener = mdriverLocationRef.addValueEventListener(new ValueEventListener() {\r\n            @Override\r\n            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {\r\n                //checking if there is a snapshot exists\r\n                if (dataSnapshot.exists() && mRequestBol) {\r\n                    //getting the data of the snapshot into list of Objects\r\n                    List<Object> map = (List<Object>) dataSnapshot.getValue();\r\n                    double LocationLat = 0;\r\n                    double LocationLng = 0;\r\n                    mRequest.setText(\"Driver Found\");\r\n                    //Check if the list has the Latitude and Longitude and assign them to the above variables\r\n                    if (map != null) {\r\n                        //check if Latitude exists and assign it\r\n                        if (map.get(0) != null) {\r\n                            LocationLat = Double.parseDouble(map.get(0).toString());\r\n                        }\r\n                        //check if Longitude exists and assign it\r\n                        if (map.get(1) != null) {\r\n                            LocationLng = Double.parseDouble(map.get(1).toString());\r\n                        }\r\n                    }\r\n                    //The LatLng of the driver\r\n                    LatLng driverLatLong = new LatLng(LocationLat, LocationLng);\r\n                    //Check if there is already a marker to remove it and not to be repeated instead it should be changed to the new location\r\n                    if (mDriverMarker != null) {\r\n                        mDriverMarker.remove();\r\n                    }\r\n                    //Location of customer\r\n                    Location loc1 = new Location(\"\");\r\n                    loc1.setLatitude(mPickupLocation.latitude);\r\n                    loc1.setLongitude(mPickupLocation.longitude);\r\n\r\n                    //Location of Driver\r\n                    Location loc2 = new Location(\"\");\r\n                    loc2.setLatitude(driverLatLong.latitude);\r\n                    loc2.setLongitude(driverLatLong.longitude);\r\n\r\n                    //Give the distance between two locations in meters\r\n                    float distance = loc1.distanceTo(loc2);\r\n\r\n                    //Notice when driver Arrives\r\n                    if (distance < 100) {\r\n                        mRequest.setText(\"Driver is here..\");\r\n                    } else {\r\n                        mRequest.setText(\"Driver found : \" + String.valueOf(distance));\r\n                    }\r\n\r\n                    //Add the driver marker on the map with a title \"Your Driver\" that will be changed later\r\n                    mDriverMarker = mMap.addMarker(new MarkerOptions().position(driverLatLong).title(\"Your Driver\").icon(BitmapDescriptorFactory.fromResource(R.mipmap.car_icon_launcher)));\r\n\r\n\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onCancelled(@NonNull DatabaseError databaseError) {\r\n                //Not needed for now\r\n            }\r\n        });\r\n    }\r\n\r\n    private DatabaseReference driveHasEndedRef;\r\n    private ValueEventListener driveHasEndedRefListener;\r\n\r\n    private void getHasRideEnded() {\r\n\r\n        //Get the custom ride id assigned to the driver\r\n        driveHasEndedRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(driverFoundID).child(\"CustomerRequest\").child(\"CustomerRideId\");\r\n        //A listener that Keep checking if a user got assigned to the customer\r\n        driveHasEndedRefListener = driveHasEndedRef.addValueEventListener(new ValueEventListener() {\r\n            @Override\r\n            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {\r\n                //Getting the assigned customer ID\r\n                if (!dataSnapshot.exists()) {\r\n                    endRide();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onCancelled(@NonNull DatabaseError databaseError) {\r\n                //Not needed for now\r\n            }\r\n        });\r\n    }\r\n\r\n    private void endRide() {\r\n\r\n        mRequestBol = false;\r\n        //When cancel the request,this will remove the listeners of getCloserDriver function\r\n        geoQuery.removeAllListeners();\r\n        // Removing of all Listeners of DatabaseRefrence\r\n        mdriverLocationRef.removeEventListener(mdriverLocationRefListener);\r\n        //Remove request data from database\r\n        //remove the driver listener\r\n        driveHasEndedRef.removeEventListener(driveHasEndedRefListener);\r\n\r\n        if (driverFoundID != null) {\r\n            DatabaseReference driverRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(driverFoundID).child(\"CustomerRequest\");\r\n            driverRef.removeValue();\r\n            driverFoundID = null;\r\n        }\r\n\r\n\r\n        driverFound = false;\r\n        radius = 1;\r\n        String userIdd = FirebaseAuth.getInstance().getCurrentUser().getUid();\r\n        DatabaseReference ref = FirebaseDatabase.getInstance().getReference(\"CustomerRequest\");\r\n        GeoFire geoFire = new GeoFire(ref);\r\n\r\n        geoFire.removeLocation(userIdd, new GeoFire.CompletionListener() {\r\n            @Override\r\n            public void onComplete(String key, DatabaseError error) {\r\n                //Handling app crashes\r\n            }\r\n        });\r\n\r\n        //Remove Pickup marker\r\n        if (mPickupMarker != null) {\r\n            mPickupMarker.remove();\r\n        }\r\n        //Change the text of button back to \"Call Uber..\"\r\n        mRequest.setText(\"Call Uber\");\r\n\r\n        mDriverInfo.setVisibility(View.GONE);\r\n        mDriverName.setText(\"\");\r\n        mDriverPhone.setText(\"\");\r\n        mDriverCar.setText(\"\");\r\n        mDriverProfileImage.setImageResource(R.mipmap.ic_launcher);\r\n\r\n\r\n    }\r\n\r\n\r\n    //This function gets the permissions needed to use the device location\r\n    private void getLocationPermission() {\r\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n            if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_FINE_LOCATION)) {\r\n                new AlertDialog.Builder(this)\r\n                        .setTitle(\"give permission\")\r\n                        .setMessage(\"give permission message\")\r\n                        .setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\r\n                            @Override\r\n                            public void onClick(DialogInterface dialogInterface, int i) {\r\n                                ActivityCompat.requestPermissions(CustomerMapActivity.this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);\r\n                            }\r\n                        })\r\n                        .create()\r\n                        .show();\r\n            } else {\r\n                ActivityCompat.requestPermissions(CustomerMapActivity.this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Getting permissions .. second part\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        switch (requestCode) {\r\n            case 1: {\r\n                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                    if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n                        mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());\r\n                        mLocationPermissionsGranted = true;\r\n                        if (mMap != null) {\r\n                            mMap.setMyLocationEnabled(true);\r\n                        }\r\n                    }\r\n                } else {\r\n                    Toast.makeText(getApplicationContext(), \"Please provide the permission\", Toast.LENGTH_LONG).show();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void getDriverInfo() {\r\n        mDriverInfo.setVisibility(View.VISIBLE);\r\n        DatabaseReference mCustomerDatabase = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(driverFoundID);\r\n\r\n        mCustomerDatabase.addListenerForSingleValueEvent(new ValueEventListener() {\r\n\r\n            @Override\r\n            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {\r\n                if (dataSnapshot.exists() && dataSnapshot.getChildrenCount() > 0) {\r\n                    Map<String, Object> map = (Map<String, Object>) dataSnapshot.getValue();\r\n                    if (map != null) {\r\n                        if (map.get(\"name\") != null) {\r\n                            mDriverName.setText(map.get(\"name\").toString());\r\n                        }\r\n                        if (map.get(\"phone\") != null) {\r\n                            mDriverPhone.setText(map.get(\"phone\").toString());\r\n                        }\r\n                        if (map.get(\"car\") != null) {\r\n                            mDriverCar.setText(map.get(\"car\").toString());\r\n                        }\r\n                        if (map.get(\"profileImageUrl\") != null) {\r\n                            Glide.with(getApplication()).load(map.get(\"profileImageUrl\").toString()).into(mDriverProfileImage);\r\n                        }\r\n\r\n                        /*\r\n                         The following section calculates the average rating of the driver and show it to the customer\r\n                          */\r\n                        int ratingSum = 0;\r\n                        float totalRating = 0;\r\n                        float averageRating = 0;\r\n                        //We loop on all rating then calculate the average by dividing the total rating on total number of rides\r\n                        //then we set the rating bar to the new number\r\n                        for (DataSnapshot child : dataSnapshot.child(\"rating\").getChildren()) {\r\n                            ratingSum += Integer.valueOf(child.getValue().toString());\r\n                            totalRating++;\r\n                        }\r\n                        if (totalRating != 0) {\r\n                            averageRating = ratingSum / totalRating;\r\n                            ratingBar.setRating(averageRating);\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onCancelled(@NonNull DatabaseError databaseError) {\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    @Override\r\n    public void onMapReady(GoogleMap googleMap) {\r\n        Log.d(TAG, \"onMapReady: map is ready\");\r\n        //Constructing the map\r\n        mMap = googleMap;\r\n\r\n        //Specifying the location request options\r\n        mLocationRequest = new LocationRequest();\r\n        mLocationRequest.setInterval(1000); // 1 second interval\r\n        mLocationRequest.setFastestInterval(1000); //the least time to take if the request is ready\r\n        mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY); // Getting accurate location\r\n\r\n        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            if (ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n\r\n            } else {\r\n                getLocationPermission();\r\n            }\r\n        }\r\n\r\n        mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());\r\n        mMap.setMyLocationEnabled(true);\r\n    }\r\n\r\n    // Turn on the My Location layer and the related control on the map.\r\n    private void updateLocationUI() {\r\n        if (mMap == null) {\r\n            return;\r\n        }\r\n        try {\r\n            if (mLocationPermissionsGranted) {\r\n                //requesting the update\r\n                mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());\r\n                mMap.setMyLocationEnabled(true);\r\n                mMap.getUiSettings().setMyLocationButtonEnabled(false);\r\n            } else {\r\n                mMap.setMyLocationEnabled(false);\r\n                mMap.getUiSettings().setMyLocationButtonEnabled(false);\r\n                mLastLocation = null;\r\n                getLocationPermission();\r\n            }\r\n        } catch (SecurityException e) {\r\n            Log.e(\"Exception: %s\", e.getMessage());\r\n        }\r\n    }\r\n\r\n    //This callback is similar to onChanged function .. here the request updates happen\r\n    LocationCallback mLocationCallback = new LocationCallback() {\r\n        @Override\r\n        public void onLocationResult(LocationResult locationResult) {\r\n            List<Location> locationList = locationResult.getLocations();\r\n            if (locationList.size() > 0) {\r\n                //The last location in the list is the newest\r\n                Location location = locationList.get(locationList.size() - 1);\r\n                Log.i(\"MapsActivity\", \"Location: \" + location.getLatitude() + \" \" + location.getLongitude());\r\n                mLastLocation = location;\r\n                if (mCurrLocationMarker != null) {\r\n                    mCurrLocationMarker.remove();\r\n                }\r\n\r\n                //Place current location marker\r\n                LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude());\r\n                MarkerOptions markerOptions = new MarkerOptions();\r\n                markerOptions.position(latLng);\r\n                markerOptions.title(\"Current Position\");\r\n                markerOptions.icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_MAGENTA));\r\n                mCurrLocationMarker = mMap.addMarker(markerOptions);\r\n\r\n                //move map camera\r\n                mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, DEFAULT_ZOOM));\r\n            }\r\n        }\r\n    };\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/hema/bakr/uperapp/CustomerMapActivity.java	(revision 6c801d865d63b3b29a3d601631f9f52bc31ac539)
+++ app/src/main/java/hema/bakr/uperapp/CustomerMapActivity.java	(date 1558116380055)
@@ -5,7 +5,6 @@
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.location.Location;
-import android.os.Build;
 import android.os.Bundle;
 import android.os.Looper;
 import android.support.annotation.NonNull;
@@ -69,9 +68,6 @@
     //Default zoom for the driver location
     private static final float DEFAULT_ZOOM = 17f;
 
-    // This variable indicates weather the permissions needed are granted
-    private Boolean mLocationPermissionsGranted = false;
-
     //This is the  top priority variable that holds the map
     private GoogleMap mMap;
 
@@ -489,17 +485,12 @@
     @Override
     public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
         super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-        switch (requestCode) {
-            case 1: {
-                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-                    if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
-                        mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());
-                        mLocationPermissionsGranted = true;
-                        if (mMap != null) {
-                            mMap.setMyLocationEnabled(true);
-                        }
+        switch(requestCode){
+            case 1:{
+                if(grantResults.length >0 && grantResults[0] == PackageManager.PERMISSION_GRANTED){
+                    if(ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED){
                     }
-                } else {
+                } else{
                     Toast.makeText(getApplicationContext(), "Please provide the permission", Toast.LENGTH_LONG).show();
                 }
                 break;
@@ -571,38 +562,11 @@
         mLocationRequest.setFastestInterval(1000); //the least time to take if the request is ready
         mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY); // Getting accurate location
 
-        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            if (ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
 
-            } else {
-                getLocationPermission();
-            }
-        }
-
+        getLocationPermission();
         mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());
         mMap.setMyLocationEnabled(true);
-    }
 
-    // Turn on the My Location layer and the related control on the map.
-    private void updateLocationUI() {
-        if (mMap == null) {
-            return;
-        }
-        try {
-            if (mLocationPermissionsGranted) {
-                //requesting the update
-                mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());
-                mMap.setMyLocationEnabled(true);
-                mMap.getUiSettings().setMyLocationButtonEnabled(false);
-            } else {
-                mMap.setMyLocationEnabled(false);
-                mMap.getUiSettings().setMyLocationButtonEnabled(false);
-                mLastLocation = null;
-                getLocationPermission();
-            }
-        } catch (SecurityException e) {
-            Log.e("Exception: %s", e.getMessage());
-        }
     }
 
     //This callback is similar to onChanged function .. here the request updates happen
Index: app/src/main/java/hema/bakr/uperapp/DriverMapActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package hema.bakr.uperapp;\r\n\r\nimport android.Manifest;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.location.Location;\r\nimport android.os.Bundle;\r\nimport android.os.Looper;\r\nimport android.support.annotation.NonNull;\r\nimport android.support.v4.app.ActivityCompat;\r\nimport android.support.v4.app.FragmentActivity;\r\nimport android.support.v4.content.ContextCompat;\r\nimport android.support.v7.app.AlertDialog;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.CompoundButton;\r\nimport android.widget.ImageView;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.Switch;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport com.bumptech.glide.Glide;\r\nimport com.directions.route.AbstractRouting;\r\nimport com.directions.route.Route;\r\nimport com.directions.route.RouteException;\r\nimport com.directions.route.Routing;\r\nimport com.directions.route.RoutingListener;\r\nimport com.firebase.geofire.GeoFire;\r\nimport com.firebase.geofire.GeoLocation;\r\nimport com.google.android.gms.location.FusedLocationProviderClient;\r\nimport com.google.android.gms.location.LocationCallback;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationResult;\r\nimport com.google.android.gms.location.LocationServices;\r\nimport com.google.android.gms.maps.CameraUpdateFactory;\r\nimport com.google.android.gms.maps.GoogleMap;\r\nimport com.google.android.gms.maps.OnMapReadyCallback;\r\nimport com.google.android.gms.maps.SupportMapFragment;\r\nimport com.google.android.gms.maps.model.LatLng;\r\nimport com.google.android.gms.maps.model.Marker;\r\nimport com.google.android.gms.maps.model.MarkerOptions;\r\nimport com.google.android.gms.maps.model.Polyline;\r\nimport com.google.android.gms.maps.model.PolylineOptions;\r\nimport com.google.firebase.auth.FirebaseAuth;\r\nimport com.google.firebase.database.DataSnapshot;\r\nimport com.google.firebase.database.DatabaseError;\r\nimport com.google.firebase.database.DatabaseReference;\r\nimport com.google.firebase.database.FirebaseDatabase;\r\nimport com.google.firebase.database.ValueEventListener;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class DriverMapActivity extends FragmentActivity implements OnMapReadyCallback, RoutingListener {\r\n\r\n    //SwitchButton for working status\r\n    private Switch mWorkingSwitch;\r\n\r\n    //The class tag is used for Logging the errors\r\n    private static final String TAG = \"MapActivity\";\r\n\r\n    //Default zoom for the driver location\r\n    private static final float DEFAULT_ZOOM = 15f;\r\n\r\n    //This is the  top priority variable that holds the map\r\n    private GoogleMap mMap;\r\n\r\n    //This variable is needed to get the driver location\r\n    private FusedLocationProviderClient mFusedLocationProviderClient;\r\n\r\n    //String variable holding the Customer Id\r\n    private String mCustomerId = \"\";\r\n\r\n    //Holds the last valid location for the driver\r\n    Location mLastLocation;\r\n    //This variable is for making updating the location of the driver by requesting as needed\r\n    LocationRequest mLocationRequest;\r\n\r\n    // this boolen used in Onstoped fuction\r\n    private Boolean IsLogedOut = false;\r\n\r\n    private LinearLayout mCustomerInfo;\r\n    private ImageView mCustomerProfileImage;\r\n    private TextView mCustomerName, mCustomerPhone, mCustomerDestination;\r\n\r\n    //the ride status button on the driver map activity\r\n    private Button mRideStatus;\r\n\r\n    private int status = 0;\r\n    private String destination;\r\n    private LatLng destiantionLatLng;\r\n    private float rideDitance;\r\n\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_driver_map);\r\n        //this arrayList for draw the route\r\n        mPolylines = new ArrayList<>();\r\n\r\n        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()\r\n                .findFragmentById(R.id.map);\r\n        mapFragment.getMapAsync(this);\r\n\r\n        // Construct a FusedLocationProviderClient.\r\n        mFusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this);\r\n\r\n        //this variables for Display customer's info on driver's screen\r\n        mCustomerInfo = findViewById(R.id.customerInfo);\r\n        mCustomerName = findViewById(R.id.customerName);\r\n        mCustomerPhone = findViewById(R.id.customerPhone);\r\n        mCustomerProfileImage = findViewById(R.id.customerProfileImage);\r\n        mCustomerDestination = findViewById(R.id.customerDestination);\r\n\r\n        mWorkingSwitch = findViewById(R.id.workingSwitch);\r\n        //this function used to check the switch button if it checked so make the driver available for customers\r\n        mWorkingSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\r\n            @Override\r\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\r\n                if(isChecked){\r\n                    //used to make the driver available for customers\r\n                    connectDriver();\r\n                }else{\r\n                    //used to make the driver Unavailable for customers\r\n                    disConnectedDriver();\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n        //A reference to the settings button\r\n        Button mSettings = findViewById(R.id.settings);\r\n        mSettings.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                Intent intent = new Intent(DriverMapActivity.this, DriverSettingsActivity.class);\r\n                startActivity(intent);\r\n            }\r\n        });\r\n\r\n        //A reference to the logout button\r\n        Button mLogout = findViewById(R.id.logout);\r\n        mLogout.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                IsLogedOut = true;\r\n\r\n                //Disconnect the driver\r\n                disConnectedDriver();\r\n\r\n                FirebaseAuth.getInstance().signOut();\r\n                Intent intent = new Intent(DriverMapActivity.this, MainActivity.class);\r\n                startActivity(intent);\r\n                finish();\r\n            }\r\n        });\r\n\r\n        mRideStatus = findViewById(R.id.ride_status);\r\n        mRideStatus.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                switch (status) {\r\n                    //Means the driver is on its way to pick up the cutomer\r\n                    case 1:\r\n                        status = 2;\r\n                        erasePolylines();\r\n                        if (destiantionLatLng.latitude != 0.0 && destiantionLatLng.longitude != 0.0) {\r\n                            getRouteToMarker(destiantionLatLng);\r\n                        }\r\n                        mRideStatus.setText(\"Drive Completed\");\r\n                        break;\r\n                    //the driver is with the customer and heading to the destiantion\r\n                    case 2:\r\n                        recordRide();\r\n                        endRide();\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n\r\n        //This function gets the driver the assigned customer to him\r\n        getAssignedCustomer();\r\n    }\r\n\r\n    //This function keeps records of all the rides\r\n    private void recordRide() {\r\n\r\n        //Getting the driver ID\r\n        String userId = FirebaseAuth.getInstance().getUid();\r\n        //Adding history child to the driver\r\n        DatabaseReference driverRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(userId).child(\"history\");\r\n        //Adding history child to the customer\r\n        DatabaseReference customerRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Customers\").child(mCustomerId).child(\"history\");\r\n        //creating \"History\" child in the main tree\r\n        DatabaseReference historyRef = FirebaseDatabase.getInstance().getReference().child(\"History\");\r\n        //Creating a unique id for the ride\r\n        String requestID = historyRef.push().getKey();\r\n        //Adding the id to the driver history child\r\n        driverRef.child(requestID).setValue(true);\r\n        //Adding the id to the customer history child\r\n        customerRef.child(requestID).setValue(true);\r\n\r\n        //Creating a map holdnig info needed to be recorded about the ride\r\n        HashMap<String, Object> map = new HashMap<>();\r\n        map.put(\"driver\", userId);\r\n        map.put(\"customer\", mCustomerId);\r\n        map.put(\"rating\", 0);\r\n        map.put(\"timestamp\", getCurrentTimestamp());\r\n        map.put(\"destination\", destination);\r\n        map.put(\"location/from/lat\", customerLatLong.latitude);\r\n        map.put(\"location/from/lng\", customerLatLong.longitude);\r\n        map.put(\"location/to/lat\", destiantionLatLng.latitude);\r\n        map.put(\"location/to/lng\", destiantionLatLng.longitude);\r\n        //save distance to databse\r\n        map.put(\"distance\", rideDitance);\r\n\r\n        //updating the \"History\" child with the data\r\n        historyRef.child(requestID).updateChildren(map);\r\n\r\n    }\r\n\r\n    private Long getCurrentTimestamp() {\r\n        Long timestamp = System.currentTimeMillis() / 1000;\r\n        return timestamp;\r\n    }\r\n\r\n    //This function check if there is assigned customer to the driver and gets it\r\n    private void getAssignedCustomer() {\r\n        // Get the current driver ID\r\n        String driverId = FirebaseAuth.getInstance().getCurrentUser().getUid();\r\n        //Get the custom ride id assigned to the driver\r\n        DatabaseReference assignedCustomerRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(driverId).child(\"CustomerRequest\").child(\"CustomerRideId\");\r\n        //A listener that Keep checking if a user got assigned to the customer\r\n        assignedCustomerRef.addValueEventListener(new ValueEventListener() {\r\n            @Override\r\n            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {\r\n                //Getting the assigned customer ID\r\n                if (dataSnapshot.exists()) {\r\n                    status = 1;\r\n                    //Get the customer ride Id assigned to the driver\r\n                    mCustomerId = dataSnapshot.getValue().toString();\r\n\r\n                    //This method get the customer Location which is the pick up location for the driver\r\n                    getAssignedCustomerLocation();\r\n                    //This function gets the destination of the customer\r\n                    getAssignedCustomerDestination();\r\n                    //for get Customer Information\r\n                    getAssignedCustomerInfo();\r\n\r\n                } else {\r\n                    endRide();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onCancelled(@NonNull DatabaseError databaseError) {\r\n                //Not needed for now\r\n            }\r\n        });\r\n    }\r\n\r\n    //For Removing marker of pickup\r\n    Marker mPickupMarker;\r\n    //For Removing data of firebase and make the driver available again\r\n    private DatabaseReference mAssignedCustomerPickupLocation;\r\n\r\n    private ValueEventListener mAssignedCustomerPickupLocationListener;\r\n    //The LatLng of the customer\r\n    LatLng customerLatLong;\r\n\r\n    //This method get the assigned customer Location for the driver\r\n    private void getAssignedCustomerLocation() {\r\n        //Get the customer reference so to be able to get the assigned customer pickup location\r\n        mAssignedCustomerPickupLocation = FirebaseDatabase.getInstance().getReference().child(\"CustomerRequest\").child(mCustomerId).child(\"l\");\r\n        //This listener keeps tracking the customer location\r\n        mAssignedCustomerPickupLocationListener = mAssignedCustomerPickupLocation.addValueEventListener(new ValueEventListener() {\r\n\r\n            @Override\r\n            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {\r\n                if (dataSnapshot.exists() && !mCustomerId.equals(\"\")) {\r\n                    //getting the data of the snapshot into list of Objects\r\n                    List<Object> map = (List<Object>) dataSnapshot.getValue();\r\n                    double LocationLat = 0;\r\n                    double LocationLng = 0;\r\n                    //Check if the list has the Latitude and Longitude and assign them to the above variables\r\n                    if (map != null) {\r\n                        //check if Latitude exists and assign it\r\n                        if (map.get(0) != null) {\r\n                            LocationLat = Double.parseDouble(map.get(0).toString());\r\n                        }\r\n                        //check if Longitude exists and assign it\r\n                        if (map.get(1) != null) {\r\n                            LocationLng = Double.parseDouble(map.get(1).toString());\r\n                        }\r\n                    }\r\n\r\n                    //The LatLng of the customer\r\n                    customerLatLong = new LatLng(LocationLat, LocationLng);\r\n\r\n                    //Add the customer marker on the map with a title \"Your Customer\" that will be changed later\r\n                    mMap.addMarker(new MarkerOptions().position(customerLatLong).title(\"Pickup Location\"));\r\n                    //get the route between customer locaton and driver locaton\r\n                    getRouteToMarker(customerLatLong);\r\n\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onCancelled(@NonNull DatabaseError databaseError) {\r\n                //Not needed for now\r\n            }\r\n        });\r\n    }\r\n\r\n    //For get Route between driver and customer\r\n    private void getRouteToMarker(LatLng customerLatLong) {\r\n        Routing routing = new Routing.Builder()\r\n                .travelMode(AbstractRouting.TravelMode.DRIVING)\r\n                .withListener(this)\r\n                .alternativeRoutes(false)\r\n                .waypoints(new LatLng(mLastLocation.getLatitude(), mLastLocation.getLongitude()), customerLatLong)\r\n                .key(getString(R.string.google_api_key))\r\n                .build();\r\n        routing.execute();\r\n    }\r\n\r\n    //This function gets the permissions needed to use the device location\r\n    private void getLocationPermission() {\r\n\r\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n            if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_FINE_LOCATION)) {\r\n                new AlertDialog.Builder(this)\r\n                        .setTitle(\"give permission\")\r\n                        .setMessage(\"give permission message\")\r\n                        .setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\r\n                            @Override\r\n                            public void onClick(DialogInterface dialogInterface, int i) {\r\n                                ActivityCompat.requestPermissions(DriverMapActivity.this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);\r\n                            }\r\n                        })\r\n                        .create()\r\n                        .show();\r\n            } else {\r\n                ActivityCompat.requestPermissions(DriverMapActivity.this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Getting permissions .. second part\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        switch (requestCode) {\r\n            case 1: {\r\n                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                    if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n                        mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());\r\n                        mMap.setMyLocationEnabled(false);\r\n                    }\r\n                } else {\r\n                    Toast.makeText(getApplicationContext(), \"Please provide the permission\", Toast.LENGTH_LONG).show();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    //This function check if there is assigned customer to the driver and gets it\r\n    private void getAssignedCustomerDestination() {\r\n        // Get the current driver ID\r\n        String driverId = FirebaseAuth.getInstance().getCurrentUser().getUid();\r\n        //Get the custom ride id assigned to the driver\r\n        DatabaseReference assignedCustomerRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(driverId).child(\"CustomerRequest\");\r\n        //A listener that Keep checking if a user got assigned to the customer\r\n        assignedCustomerRef.addListenerForSingleValueEvent(new ValueEventListener() {\r\n            @Override\r\n            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {\r\n                //Getting the assigned customer ID\r\n                if (dataSnapshot.exists()) {\r\n                    Map<String, Object> map = (Map<String, Object>) dataSnapshot.getValue();\r\n\r\n                    if (map.get(\"destination\") != null) {\r\n                        destination = map.get(\"destination\").toString();\r\n                        mCustomerDestination.setText(\"Destination:\" + destination);\r\n                    } else {\r\n                        mCustomerDestination.setText(\"Destination : -- \");\r\n                    }\r\n\r\n                    double destiantionLat = 0.0, destiantionLng = 0.0;\r\n\r\n                    if (map.get(\"destinationLat\") != null) {\r\n                        destiantionLat = Double.parseDouble(map.get(\"destinationLat\").toString());\r\n                    }\r\n                    if (map.get(\"destinationLng\") != null) {\r\n                        destiantionLng = Double.valueOf(map.get(\"destinationLng\").toString());\r\n                    }\r\n\r\n                    destiantionLatLng = new LatLng(destiantionLat, destiantionLng);\r\n\r\n\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onCancelled(@NonNull DatabaseError databaseError) {\r\n                //Not needed for now\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    // for get customer's info from database and Display it on driver's screen\r\n    private void getAssignedCustomerInfo() {\r\n        mCustomerInfo.setVisibility(View.VISIBLE);\r\n        DatabaseReference mCustomerDatabase = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Customers\").child(mCustomerId);\r\n\r\n        mCustomerDatabase.addListenerForSingleValueEvent(new ValueEventListener() {\r\n\r\n            @Override\r\n            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {\r\n                if (dataSnapshot.exists() && dataSnapshot.getChildrenCount() > 0) {\r\n                    Map<String, Object> map = (Map<String, Object>) dataSnapshot.getValue();\r\n                    if (map != null) {\r\n                        if (map.get(\"name\") != null) {\r\n                            mCustomerName.setText(map.get(\"name\").toString());\r\n                        }\r\n                        if (map.get(\"phone\") != null) {\r\n                            mCustomerPhone.setText(map.get(\"phone\").toString());\r\n                        }\r\n                        if (map.get(\"profileImageUrl\") != null) {\r\n                            Glide.with(getApplication()).load(map.get(\"profileImageUrl\").toString()).into(mCustomerProfileImage);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onCancelled(@NonNull DatabaseError databaseError) {\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    public void onMapReady(GoogleMap googleMap) {\r\n        Log.d(TAG, \"onMapReady: map is ready\");\r\n        //Constructing the map\r\n        mMap = googleMap;\r\n\r\n        //Specifying the location request options\r\n        mLocationRequest = new LocationRequest();\r\n        mLocationRequest.setInterval(1000); // 1 second interval\r\n        mLocationRequest.setFastestInterval(1000); //the least time to take if the request is ready\r\n        mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY); // Getting accurate location\r\n\r\n\r\n    }\r\n\r\n\r\n    //This callback is similar to onChanged function .. here the request updates happen\r\n    LocationCallback mLocationCallback = new LocationCallback() {\r\n        @Override\r\n        public void onLocationResult(LocationResult locationResult) {\r\n            for (Location location : locationResult.getLocations()) {\r\n                if (getApplicationContext() != null) {\r\n\r\n                    Log.i(\"MapsActivity\", \"Location: \" + location.getLatitude() + \" \" + location.getLongitude());\r\n\r\n                    // calculate distance part 35\r\n\r\n                    if (!mCustomerId.equals(\"\")){\r\n                        // divied to 1000 for km\r\n                        rideDitance += mLastLocation.distanceTo(location)/1000;\r\n                    }\r\n\r\n                    mLastLocation = location;\r\n                    LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude());\r\n                    mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, DEFAULT_ZOOM));\r\n\r\n                    //Get the user id to check later if it is assigned to the driver\r\n                    String userId = FirebaseAuth.getInstance().getCurrentUser().getUid();\r\n                    DatabaseReference refAvailable = FirebaseDatabase.getInstance().getReference(\"DriverAvailable\");\r\n                    DatabaseReference refWorking = FirebaseDatabase.getInstance().getReference(\"DriverWorking\");\r\n                    GeoFire geoFireAvailable = new GeoFire(refAvailable);\r\n                    GeoFire geoFireWorking = new GeoFire(refWorking);\r\n\r\n                    switch (mCustomerId) {\r\n                        //This case when no user is assigned to the customer\r\n                        case \"\":\r\n                            geoFireWorking.removeLocation(userId, new GeoFire.CompletionListener() {\r\n                                @Override\r\n                                public void onComplete(String key, DatabaseError error) {\r\n                                    //This listener prevent the app from crashing\r\n                                }\r\n                            });\r\n                            geoFireAvailable.setLocation(userId, new GeoLocation(location.getLatitude(), location.getLongitude()), new GeoFire.CompletionListener() {\r\n                                @Override\r\n                                public void onComplete(String key, DatabaseError error) {\r\n                                    //This listener prevent the app from crashing\r\n                                }\r\n                            });\r\n                            Log.i(TAG, \"Everything is okay\");\r\n                            break;\r\n                        default:\r\n                            //This case when a user is assigned to the customer\r\n                            geoFireAvailable.removeLocation(userId, new GeoFire.CompletionListener() {\r\n                                @Override\r\n                                public void onComplete(String key, DatabaseError error) {\r\n                                    //This listener prevent the app from crashing\r\n                                }\r\n                            });\r\n                            geoFireWorking.setLocation(userId, new GeoLocation(location.getLatitude(), location.getLongitude()), new GeoFire.CompletionListener() {\r\n                                @Override\r\n                                public void onComplete(String key, DatabaseError error) {\r\n                                    //This listener prevent the app from crashing\r\n                                }\r\n                            });\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    private void connectDriver(){\r\n        //take the permission to use GPS\r\n        getLocationPermission();\r\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n            // TODO: Consider calling\r\n            //    ActivityCompat#requestPermissions\r\n            // here to request the missing permissions, and then overriding\r\n            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n            //                                          int[] grantResults)\r\n            // to handle the case where the user grants the permission. See the documentation\r\n            // for ActivityCompat#requestPermissions for more details.\r\n            return;\r\n        }\r\n        //used to make the driver available for customers and callback getting the location\r\n        mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());\r\n        mMap.setMyLocationEnabled(true);\r\n    }\r\n\r\n    private void disConnectedDriver() {\r\n        //Stopping the callback from getting the location\r\n        mFusedLocationProviderClient.removeLocationUpdates(mLocationCallback);\r\n\r\n        String userid = FirebaseAuth.getInstance().getCurrentUser().getUid();\r\n\r\n        DatabaseReference ref = FirebaseDatabase.getInstance().getReference(\"DriverAvailable\");\r\n\r\n        GeoFire geoFire = new GeoFire(ref);\r\n        //the listener must be added to prevent the app from crashing\r\n        geoFire.removeLocation(userid, new GeoFire.CompletionListener() {\r\n            @Override\r\n            public void onComplete(String key, DatabaseError error) {\r\n                Log.i(\"Success\", \"Driver removed Successfully\");\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n\r\n    //all this part of Overrided methods for draw the route between customer and driver\r\n    private List<Polyline> mPolylines;\r\n    private static final int[] COLORS = new int[]{R.color.polylines, android.R.color.holo_blue_dark, android.R.color.holo_orange_dark};\r\n\r\n    @Override\r\n    public void onRoutingFailure(RouteException e) {\r\n        // The Routing request failed\r\n        if (e != null) {\r\n            Toast.makeText(this, \"Error: \" + e.getMessage(), Toast.LENGTH_LONG).show();\r\n        } else {\r\n            Toast.makeText(this, \"Something went wrong, Try again\", Toast.LENGTH_SHORT).show();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRoutingStart() {\r\n    }\r\n\r\n    @Override\r\n    public void onRoutingSuccess(ArrayList<Route> route, int shortestRouteIndex) {\r\n\r\n        //Draw the route between if routing success between the customer and the driver\r\n        if (mPolylines.size() > 0) {\r\n            for (Polyline poly : mPolylines) {\r\n                poly.remove();\r\n            }\r\n        }\r\n        mPolylines = new ArrayList<>();\r\n        //add route(s) to the map.\r\n        for (int i = 0; i < route.size(); i++) {\r\n\r\n            //In case of more than 5 alternative routes\r\n            int colorIndex = i % COLORS.length;\r\n\r\n            PolylineOptions polyOptions = new PolylineOptions();\r\n            polyOptions.color(getResources().getColor(COLORS[colorIndex]));\r\n            polyOptions.width(10 + i * 3);\r\n            polyOptions.addAll(route.get(i).getPoints());\r\n            Polyline polyline = mMap.addPolyline(polyOptions);\r\n            mPolylines.add(polyline);\r\n\r\n            Toast.makeText(getApplicationContext(), \"Route \" + (i + 1) + \": distance - \" + route.get(i).getDistanceValue() + \": duration - \" + route.get(i).getDurationValue(), Toast.LENGTH_SHORT).show();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRoutingCancelled() {\r\n    }\r\n\r\n    //this method for clear the route from map\r\n    private void erasePolylines() {\r\n        for (Polyline line : mPolylines) {\r\n            line.remove();\r\n        }\r\n        mPolylines.clear();\r\n    }\r\n\r\n    //This function ends the trip and remove the data from the database\r\n    private void endRide() {\r\n\r\n        mRideStatus.setText(\"Picked Customer\");\r\n\r\n        erasePolylines();\r\n\r\n        String userId = FirebaseAuth.getInstance().getUid();\r\n        DatabaseReference driverRef = FirebaseDatabase.getInstance().getReference().child(\"Users\").child(\"Riders\").child(userId).child(\"CustomerRequest\");\r\n        driverRef.removeValue();\r\n\r\n        DatabaseReference ref = FirebaseDatabase.getInstance().getReference(\"CustomerRequest\");\r\n        GeoFire geoFire = new GeoFire(ref);\r\n        geoFire.removeLocation(mCustomerId, new GeoFire.CompletionListener() {\r\n            @Override\r\n            public void onComplete(String key, DatabaseError error) {\r\n                //This listener prevent the app from crashing\r\n            }\r\n        });\r\n        mCustomerId = \"\";\r\n        // make distance zero for new trip\r\n        rideDitance=0;\r\n\r\n        //Remove Pickup marker\r\n        if (mPickupMarker != null) {\r\n            mPickupMarker.remove();\r\n        }\r\n\r\n        if (mAssignedCustomerPickupLocationListener != null) {\r\n            mAssignedCustomerPickupLocation.removeEventListener(mAssignedCustomerPickupLocationListener);\r\n        }\r\n\r\n        mCustomerInfo.setVisibility(View.GONE);\r\n        mCustomerName.setText(\"\");\r\n        mCustomerPhone.setText(\"\");\r\n        mCustomerDestination.setText(\"Destination : --\");\r\n        mCustomerProfileImage.setImageResource(R.mipmap.ic_launcher);\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void onStop() {\r\n        super.onStop();\r\n        mWorkingSwitch.setChecked(false);\r\n        disConnectedDriver();\r\n    }   \r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/hema/bakr/uperapp/DriverMapActivity.java	(revision 6c801d865d63b3b29a3d601631f9f52bc31ac539)
+++ app/src/main/java/hema/bakr/uperapp/DriverMapActivity.java	(date 1558114411217)
@@ -531,17 +531,7 @@
     private void connectDriver(){
         //take the permission to use GPS
         getLocationPermission();
-        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
-            // TODO: Consider calling
-            //    ActivityCompat#requestPermissions
-            // here to request the missing permissions, and then overriding
-            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
-            //                                          int[] grantResults)
-            // to handle the case where the user grants the permission. See the documentation
-            // for ActivityCompat#requestPermissions for more details.
-            return;
-        }
-        //used to make the driver available for customers and callback getting the location
+
         mFusedLocationProviderClient.requestLocationUpdates(mLocationRequest, mLocationCallback, Looper.myLooper());
         mMap.setMyLocationEnabled(true);
     }
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"GradleSettings\">\r\n    <option name=\"linkedExternalProjectsSettings\">\r\n      <GradleProjectSettings>\r\n        <compositeConfiguration>\r\n          <compositeBuild compositeDefinitionSource=\"SCRIPT\" />\r\n        </compositeConfiguration>\r\n        <option name=\"distributionType\" value=\"DEFAULT_WRAPPED\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"modules\">\r\n          <set>\r\n            <option value=\"$PROJECT_DIR$\" />\r\n            <option value=\"$PROJECT_DIR$/app\" />\r\n          </set>\r\n        </option>\r\n        <option name=\"resolveModulePerSourceSet\" value=\"false\" />\r\n      </GradleProjectSettings>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision 6c801d865d63b3b29a3d601631f9f52bc31ac539)
+++ .idea/gradle.xml	(date 1558110988284)
@@ -3,9 +3,6 @@
   <component name="GradleSettings">
     <option name="linkedExternalProjectsSettings">
       <GradleProjectSettings>
-        <compositeConfiguration>
-          <compositeBuild compositeDefinitionSource="SCRIPT" />
-        </compositeConfiguration>
         <option name="distributionType" value="DEFAULT_WRAPPED" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
         <option name="modules">
